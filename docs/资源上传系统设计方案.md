# 资源上传系统设计方案

## 一、需求概述

在 go_blog 项目的后台管理中，为管理员实现一个"资源上传"功能，支持视频、图片、文档等常见文件类型的上传。

### 核心功能

- ✅ 普通上传（小文件 <10MB）
- ✅ 断点续传（大文件 ≥10MB）
- ✅ 秒传（文件MD5检测）
- ✅ 并发上传（3-5个并发）
- ✅ 进度跟踪
- ✅ 文件类型验证

> **注意**：本功能仅供管理员内部使用，无需配额管理和速率限制。

---

## 二、上传流程

### 2.1 流程总览

```
┌─────────────────────────────────────────────────────────────┐
│                      前端计算文件 MD5                         │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                   POST /check (秒传检测)                      │
│  ┌──────────────┬──────────────┬──────────────┐             │
│  │   秒传成功    │   断点续传    │    新文件     │             │
│  │  返回URL     │ 返回任务+缺块  │   返回空      │             │
│  └──────────────┴──────────────┴──────────────┘             │
└─────────────────────────────────────────────────────────────┘
        ↓                    ↓                    ↓
     结束              继续上传缺块           POST /init
                                              创建任务
                              ↓                    ↓
                    ┌─────────────────────────────────────────┐
                    │         判断文件大小                      │
                    │   < 10MB: 普通上传（单次请求）            │
                    │   ≥ 10MB: 断点续传（分片上传）            │
                    └─────────────────────────────────────────┘
                              ↓
                    ┌─────────────────────────────────────────┐
                    │    前端主动调用 POST /complete            │
                    │    后端合并文件，返回URL                  │
                    └─────────────────────────────────────────┘
```

### 2.2 场景一：秒传

```
条件：resources 表中已存在相同 file_hash 的记录

流程：
1. 前端计算文件 MD5
2. POST /check {file_hash, file_size, file_name}
3. 后端查询 resources 表，找到相同 hash
4. 后端创建新的 resources 记录（指向同一物理文件）
5. 返回 {exists: true, file_url: "..."}
6. 结束（无需上传）

耗时：< 1秒
```

### 2.3 场景二：普通上传（小文件 <10MB）

```
流程：
1. 前端计算文件 MD5
2. POST /check → 返回空（新文件）
3. POST /init 创建任务
4. POST /upload-chunk 一次性上传整个文件（单次请求）
5. 前端主动调用 POST /complete
6. 后端存储到七牛云，创建 resources 记录
7. 返回 CDN URL

特点：
- 单次请求完成上传
- 实现简单
```

### 2.4 场景三：断点续传（大文件 ≥10MB）

```
流程：
1. 前端计算文件 MD5
2. POST /check
   → 新文件：POST /init 创建任务，初始化 QiniuContexts 数组
   → 续传：返回 task_id 和 missing_chunks
3. 前端切片（4MB一块）
4. 并发上传缺失的块（3个并发）
   - POST /upload-chunk {task_id, chunk_number, chunk_data}
   - 后端调用七牛云 mkblk，获取 Context
   - 后端用 JSON_SET 原子更新 QiniuContexts[$chunk_number]
5. 前端主动调用 POST /complete
   - 后端获取所有 Context（按顺序）
   - 调用七牛云 mkfile 合并
   - 创建 resources 记录
   - 返回 CDN URL

特点：
- 支持暂停/继续
- 支持刷新页面后继续
- 支持跨设备续传
- 失败只重传失败的块
- 并发提升速度
```

### 2.5 为什么前端触发 /complete？

```
业界标准做法：前端主动通知服务端进行合并

原因：
1. 前端知道何时完成 - 前端跟踪所有块的上传状态
2. 后端无法自动判断 - 后端不知道用户是否暂停了上传
3. 支持取消上传 - 用户可以中途取消，不触发合并
```

---

## 三、技术架构

### 3.1 存储方案

```
临时块存储：七牛云OSS
- 7天有效期，自动清理
- 免费（只为最终文件付费）

状态管理：本地MySQL
- 记录上传进度
- 保存七牛云Context

最终文件：七牛云OSS
- CDN加速
- 高可用
```

---

## 四、数据库设计

> **说明**：采用双表设计，任务表存临时数据，资源表存永久数据，两表独立不关联。

### 4.1 上传任务表（临时）

```go
// internal/model/database/resource_upload_task.go

// TaskStatus 任务状态枚举
type TaskStatus int8

const (
    TaskStatusInit      TaskStatus = 0 // 初始化
    TaskStatusUploading TaskStatus = 1 // 上传中
    TaskStatusCompleted TaskStatus = 2 // 已完成
    TaskStatusCancelled TaskStatus = 3 // 已取消
    TaskStatusFailed    TaskStatus = 4 // 失败
)

// ResourceUploadTask 资源上传任务表
type ResourceUploadTask struct {
    global.MODEL
    TaskID        string     `gorm:"size:64;uniqueIndex;not null;comment:任务ID(UUID)"`
    FileHash      string     `gorm:"size:64;index;comment:文件MD5(前端计算)"`
    FileName      string     `gorm:"size:255;not null;comment:文件名"`
    FileSize      int64      `gorm:"not null;comment:文件大小(字节)"`
    MimeType      string     `gorm:"size:100;not null;comment:MIME类型"`
    ChunkSize     int        `gorm:"default:4194304;comment:分片大小(4MB)"`
    TotalChunks   int        `gorm:"not null;comment:总分片数"`
    QiniuContexts string     `gorm:"type:json;comment:七牛云Context(JSON数组,索引=块号)"`
    Status        TaskStatus `gorm:"default:0;index;comment:状态:0初始化,1上传中,2完成,3取消,4失败"`
    UserUUID      uuid.UUID  `gorm:"type:char(36);index;comment:用户UUID"`
    ExpiresAt     *time.Time `gorm:"comment:过期时间(24小时)"`
}

// QiniuContexts 格式说明：
// - 初始化时：["", "", "", ...] (长度=TotalChunks)
// - 上传块后：["ctx0", "ctx1", "", "ctx3", ...] (非空=已上传)
// - 并发更新：使用 MySQL JSON_SET 原子操作
//   UPDATE ... SET qiniu_contexts = JSON_SET(qiniu_contexts, '$[2]', 'ctx2')
```

### 4.2 资源表（永久）

```go
// internal/model/database/resource.go

// Resource 资源表
// 秒传说明：相同 FileHash 的文件只存一份物理文件，但每个用户有独立记录
type Resource struct {
    global.MODEL
    FileKey  string    `gorm:"size:500;not null;comment:七牛云Key(不含域名)"`
    FileName string    `gorm:"size:255;not null;comment:文件名"`
    FileHash string    `gorm:"size:64;index;comment:文件MD5(秒传检测用)"`
    FileSize int64     `gorm:"not null;comment:文件大小(字节)"`
    MimeType string    `gorm:"size:100;not null;comment:MIME类型"`
    UserUUID uuid.UUID `gorm:"type:char(36);index;comment:用户UUID"`
    User     User      `gorm:"foreignKey:UserUUID;references:UUID"`
}

// 联合唯一索引：同一用户不能重复上传相同文件
// CREATE UNIQUE INDEX idx_user_hash ON resources(user_uuid, file_hash)
```

### 4.3 表设计说明

| 表名 | 用途 | 生命周期 | 关联 |
|------|------|----------|------|
| `resource_upload_tasks` | 上传过程状态 | 临时（可定期清理） | 无 |
| `resources` | 最终文件记录 | 永久 | User |

### 4.4 秒传机制

**原理**：相同 MD5 的文件只存一份物理文件，每个用户有独立的数据库记录

```
用户A 上传 video.mp4 (MD5: abc123)
  → 检查 resources 表，不存在
  → 创建任务，上传到七牛云
  → 写入 resources 表：{file_key: "res/abc123.mp4", user_uuid: A}

用户B 上传 video.mp4 (MD5: abc123)
  → 检查 resources 表，已存在！
  → 秒传：直接写入 resources 表：{file_key: "res/abc123.mp4", user_uuid: B}
  → 不创建任务，不重复上传
```

**优点**：
- 节省存储空间（同文件只存一份）
- 秒传体验好
- 业界标准做法（百度网盘、阿里云盘）

---

## 五、API设计

### 5.1 API端点

```
1. 检查文件（秒传/续传检测）
POST /api/admin/resources/check
Request:
{
  "file_hash": "abc123...",   // 文件MD5（前端计算）
  "file_size": 104857600,     // 文件大小（字节）
  "file_name": "video.mp4"    // 文件名
}
Response:
// 场景1：秒传成功
{
  "exists": true,
  "file_url": "https://cdn.example.com/res/abc123.mp4"
}
// 场景2：断点续传
{
  "exists": false,
  "task_id": "uuid-xxx",
  "total_chunks": 25,
  "uploaded_chunks": [0, 1, 3, 5],   // 已上传的块号
  "missing_chunks": [2, 4, 6, ...]   // 缺失的块号
}
// 场景3：新文件
{
  "exists": false,
  "task_id": null
}

2. 初始化上传任务
POST /api/admin/resources/init
Request:
{
  "file_hash": "abc123...",
  "file_size": 104857600,
  "file_name": "video.mp4",
  "mime_type": "video/mp4"
}
Response:
{
  "task_id": "uuid-xxx",
  "total_chunks": 25,
  "chunk_size": 4194304   // 4MB
}

3. 上传分片
POST /api/admin/resources/upload-chunk
Content-Type: multipart/form-data
Fields:
  - task_id: "uuid-xxx"
  - chunk_number: 0        // 块号（从0开始）
  - chunk_data: [binary]   // 块数据
Response:
{
  "success": true,
  "chunk_number": 0
}

4. 查询上传进度（可选，用于跨设备查看）
GET /api/admin/resources/progress?task_id=uuid-xxx
Response:
{
  "task_id": "uuid-xxx",
  "total_chunks": 25,
  "uploaded_chunks": [0, 1, 3, 5],
  "missing_chunks": [2, 4, 6, ...],
  "progress": 16   // 百分比（按块计算）
}

5. 完成上传
POST /api/admin/resources/complete
Request:
{
  "task_id": "uuid-xxx"
}
Response:
{
  "file_url": "https://cdn.example.com/res/abc123.mp4",
  "file_key": "res/abc123.mp4"
}

6. 取消上传
POST /api/admin/resources/cancel
Request:
{
  "task_id": "uuid-xxx"
}
Response:
{
  "success": true
}
```

---

## 六、Interface 设计

> **注意**：本系统与现有 `pkg/utils/upload/OSS` 接口完全独立。
> 现有 OSS 接口仅适配图片上传，本系统支持多种文件类型的普通上传和断点续传。

### 6.1 ResourceUploader - 资源上传接口（必须）

```
// pkg/resource/uploader.go
// 支持切换不同云存储提供商

interface ResourceUploader {
    // === 普通上传（小文件 <10MB）===
    Upload(data []byte, fileName string, mimeType string) -> (fileKey string, error)
    
    // === 分片上传（大文件 ≥10MB）===
    // 上传块到云存储
    UploadBlock(blockData []byte) -> (context string, error)
    
    // 合并所有块为最终文件
    MergeBlocks(fileSize int64, fileName string, contexts []string) -> (fileKey string, error)
    
    // === 通用方法 ===
    // 获取文件的CDN URL
    GetFileURL(fileKey string) -> string
    
    // 删除文件
    DeleteFile(fileKey string) -> error
}

// 实现
- QiniuResourceUploader   // 七牛云（当前）
- AliyunResourceUploader  // 阿里云OSS（未来）
- LocalResourceUploader   // 本地存储（测试）
```

### 6.2 FileValidator - 文件验证器（推荐）

```
// 支持不同验证策略
interface FileValidator {
    // 验证MIME类型
    ValidateMimeType(mimeType string) -> error
    
    // 验证文件签名（Magic Number）
    ValidateSignature(data []byte, mimeType string) -> error
    
    // 验证文件大小
    ValidateSize(size int64) -> error
}

// 实现
- DefaultValidator   // 白名单验证
- StrictValidator    // 签名+白名单验证
```

### 6.3 TaskStore - 任务存储（可选）

```
// 支持不同存储后端
interface TaskStore {
    CreateTask(task *UploadTask) -> error
    GetTask(taskID string) -> (*UploadTask, error)
    UpdateTask(task *UploadTask) -> error
    DeleteTask(taskID string) -> error
    GetExpiredTasks() -> ([]*UploadTask, error)
}

// 实现
- MySQLTaskStore    // MySQL（当前）
- RedisTaskStore    // Redis缓存（高性能）
- MemoryTaskStore   // 内存（测试）
```

### 6.4 Interface 设计优势

- ✅ **可扩展**：支持切换云存储提供商
- ✅ **可测试**：便于 Mock 进行单元测试
- ✅ **低耦合**：业务逻辑与存储实现分离
- ✅ **SOLID**：符合依赖倒置原则

---

## 七、核心流程（伪代码）

### 7.1 目录结构

```
server-blog/
├── pkg/resource/              # 新的资源管理包（独立于现有 pkg/utils/upload/）
│   ├── uploader.go           # ResourceUploader 接口定义
│   ├── qiniu.go              # 七牛云实现 (QiniuResourceUploader)
│   ├── validator.go          # FileValidator 接口和实现
│   └── task_store.go         # TaskStore 接口定义
│
├── pkg/utils/upload/          # 现有图片上传（保持不变）
│   ├── upload.go             # OSS 接口（仅图片）
│   ├── qiniu.go              # 七牛云图片上传
│   └── local.go              # 本地图片上传
│
├── internal/
│   ├── model/database/
│   │   └── resource_upload_task.go  # 上传任务模型
│   ├── service/resource.go          # 资源上传服务
│   ├── api/resource.go              # 资源上传API
│   └── router/resource.go           # 资源路由
```

### 7.2 七牛云分片上传（伪代码）

```
UploadBlock(blockData):
    1. 生成上传凭证 upToken
    2. POST /mkblk/{blockSize} 到七牛云
    3. 返回 Context（块的唯一标识）

MergeBlocks(fileSize, fileName, contexts[]):
    1. 生成上传凭证 upToken
    2. Base64编码文件名
    3. POST /mkfile/{fileSize}/key/{encodedKey}
       请求体: context1,context2,context3,...  ⭐ 按顺序逗号分隔
    4. 七牛云自动合并，返回文件Key
```

### 7.3 Service层核心流程（伪代码）

```
CheckFile(fileHash):
    1. 查询数据库：file_hash = ? AND status = 已完成
       → 找到：返回文件URL（秒传）
    2. 查询数据库：file_hash = ? AND status = 未完成
       → 找到：返回任务ID和已上传块列表（续传）
    3. 未找到：返回空

UploadChunk(taskID, chunkNumber, chunkData):
    1. 查询任务
    2. 调用 UploadBlock 上传到七牛云，获取 Context
    3. 保存 Context 到数据库（按块序号存储）⭐ 关键
    4. 更新已上传块列表
    5. 保存到数据库

CompleteUpload(taskID):
    1. 查询任务
    2. 获取所有 Context（按顺序）
    3. 调用 MergeBlocks 合并 ⭐ 关键
    4. 更新任务状态为已完成
    5. 返回 CDN URL
```

---

## 八、文件验证

### 8.1 文件类型白名单

```
允许的MIME类型：
- image/jpeg, image/png, image/gif, image/webp
- video/mp4, video/webm
- application/pdf
- application/msword, application/vnd.openxmlformats-officedocument.*
```

### 8.2 文件签名验证

```
文件魔数检测：
- JPEG: FF D8 FF
- PNG:  89 50 4E 47
- MP4:  00 00 00 18 66 74 79 70
- PDF:  25 50 44 46
```

### 8.3 定时清理

```
每小时执行：
    查询 status IN (初始化, 上传中) AND expires_at < 当前时间
    删除过期的未完成任务
```

---

## 九、前端流程（伪代码）

```
uploadFile(file):
    1. 计算文件MD5
    
    2. 检查文件是否存在（秒传）
       POST /api/admin/resources/check
       → 已完成：直接返回URL
       → 未完成：获取任务ID和已上传块
       → 不存在：初始化新任务
    
    3. 切片（4MB一块）
       chunks = file.slice(0, 4MB), file.slice(4MB, 8MB), ...
    
    4. 过滤已上传的块
       pendingChunks = chunks.filter(未上传)
    
    5. 并发上传（3个并发）
       for batch in pendingChunks.batch(3):
           await Promise.all(batch.map(uploadChunk))
           更新进度
    
    6. 完成上传
       POST /api/admin/resources/complete
       返回最终URL
```

---

## 十、关键技术点

### 10.1 Context存储位置

```
❌ 错误：前端存储Context
- 刷新页面丢失
- 跨设备续传无法实现

✅ 正确：后端数据库存储Context
- 持久化存储
- 支持跨设备续传
```

### 10.2 并发上传

```
前端并发控制：
- 推荐3-5个并发上传
- 失败自动重试3次，指数退避（1s, 2s, 4s）
```

### 10.3 并发更新（数据库）

```
问题：多个块同时上传，同时更新 QiniuContexts 字段

解决方案：MySQL JSON 原子操作（无需加锁）

-- 上传块2后，原子更新
UPDATE resource_upload_tasks 
SET qiniu_contexts = JSON_SET(qiniu_contexts, '$[2]', 'ctx2_base64...')
WHERE task_id = ?

-- 上传块5后，原子更新（不冲突）
UPDATE resource_upload_tasks 
SET qiniu_contexts = JSON_SET(qiniu_contexts, '$[5]', 'ctx5_base64...')
WHERE task_id = ?
```

### 10.4 断点续传

```
恢复上传时，计算缺失的块：

1. 查询任务的 QiniuContexts
   ["ctx0", "ctx1", "", "ctx3", "", "ctx5"]

2. 计算已上传块（非空索引）
   uploaded_chunks = [0, 1, 3, 5]

3. 计算缺失块（空索引）
   missing_chunks = [2, 4]

4. 返回给前端，只上传缺失的块
```

### 10.5 MD5 计算

```
前端计算文件 MD5（使用 spark-md5 库）：
- 分块计算，避免内存溢出
- 用于秒传检测和断点续传识别
```

---

## 十一、七牛云视频转码与回调

### 11.1 工作流配置

在七牛云控制台配置工作流模板，实现视频上传后自动转码和生成缩略图。

**工作流结构（并行分支）：**

```
触发器（上传视频到 resource/ 目录）
    │
    ├─── 分支1：视频转码（avsmart 锐智转码）
    │         输出：resource/${keybase}_h264.mp4
    │
    └─── 分支2：提取缩略图（vframe）
              输出：resource/${keybase}_thumb.jpg
```

### 11.2 回调接口

**接口地址：** `POST /api/qiniu/callback`

**回调数据示例：**

```json
{
  "id": "z2.01z221dfh9uw4s8tpl00mvgp0f000kvg",
  "pipeline": "1383102879.default.sys",
  "code": 0,
  "desc": "The fop was completed successfully",
  "reqid": "Dn0AAADmzfKNDogY",
  "inputBucket": "hsk",
  "inputKey": "resource/39d195617f3aad6d4f1b985a085d60da.mp4",
  "items": [
    {
      "cmd": "avthumb/mp4/vcodec/libx264/acodec/libfdk_aac/avsmart/1|saveas/aHNr/savePattern/JHtrZXliYXNlfV9oMjY0Lm1wNA==",
      "code": 0,
      "desc": "The fop was completed successfully",
      "hash": "FhJJvXuNPOtKqM_YqQ_Hjl7LVz_3",
      "key": "resource/39d195617f3aad6d4f1b985a085d60da_h264.mp4",
      "returnOld": 0
    },
    {
      "cmd": "vframe/jpg/offset/1|saveas/aHNr/savePattern/JHtrZXliYXNlfV90aHVtYi5qcGc=",
      "code": 0,
      "desc": "The fop was completed successfully",
      "hash": "FvFpWBUzqnjIKUkWksGip4OqsLdg",
      "key": "resource/39d195617f3aad6d4f1b985a085d60da_thumb.jpg",
      "returnOld": 0
    }
  ],
  "creationDate": "2026-01-06T13:54:16.674203324+08:00"
}
```

### 11.3 关键字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | string | 任务ID（persistentId） |
| `code` | int | 整体状态码：0=成功, 1=等待, 2=处理中, 3=失败 |
| `inputBucket` | string | 源文件所在的 bucket |
| `inputKey` | string | **源文件的 key，用于匹配数据库记录** |
| `items` | array | 处理结果数组 |
| `items[].cmd` | string | 处理命令 |
| `items[].code` | int | 该项状态码 |
| `items[].key` | string | **输出文件的 key** |
| `items[].hash` | string | 输出文件的 hash |

### 11.4 回调处理逻辑

```go
// 1. 根据 inputKey 查找数据库记录
// inputKey = "resource/39d195617f3aad6d4f1b985a085d60da.mp4"
// 数据库 file_key = "resource/39d195617f3aad6d4f1b985a085d60da.mp4"
resource := db.Where("file_key = ?", inputKey).First()

// 2. 遍历 items，更新对应字段
for _, item := range items {
    if strings.Contains(item.Cmd, "avthumb") && item.Code == 0 {
        // 转码结果 - 更新 file_url 为转码后的视频
        resource.FileUrl = domain + "/" + item.Key
    }
    if strings.Contains(item.Cmd, "vframe") && item.Code == 0 {
        // 截图结果 - 更新缩略图 URL
        resource.ThumbnailUrl = domain + "/" + item.Key
    }
}

// 3. 更新数据库
db.Save(resource)
```

### 11.5 回调重试机制

七牛云的回调重试策略：
- **重试次数**：13 次
- **重试间隔**：1s → 2s → 4s → 8s → 16s → 32s → ... → 最大 3600s
- **重试条件**：回调超时或返回 5xx 状态码

### 11.6 前端缩略图显示

在资源列表页面，根据文件类型显示不同的预览：

```typescript
// 根据文件URL生成缩略图URL
function getThumbnailUrl(fileUrl: string, mimeType: string): string {
  // 图片直接返回原URL
  if (mimeType.startsWith('image/')) {
    return fileUrl
  }
  
  // 视频生成缩略图URL：xxx.mp4 → xxx_thumb.jpg
  if (mimeType.startsWith('video/')) {
    const lastDotIndex = fileUrl.lastIndexOf('.')
    if (lastDotIndex === -1) return ''
    return fileUrl.substring(0, lastDotIndex) + '_thumb.jpg'
  }
  
  return ''
}
```

---

**文档版本：** v1.3  
**最后更新：** 2026-01-06
